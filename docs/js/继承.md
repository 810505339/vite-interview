# Javascript 6大继承 最优是寄生组合继承

## 原型链继承
  原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着三角的关系，即每一个构造函数都有一个原型对象```「prototype」```，原型对象又包含一个指向构造函数的指针「constructor」，然后实例则包含一个隐式原型对象的指针「__ proto __ 称为隐式原型我想做一层区分而已帮助理解，抱歉因为Markdown语法关系，__ proto __ 存在空格」。

示例代码:
``` ts
function Parent(){
  this.name='parent'
  this.list=[1,2,3,4]

}

function Child(){
  this.type='child'
}
Child.prototype=new Parent()

const c=new Child()
const c1=new Child()
c1.list.push(5)
console.log(c.name) //parent
console.log(c.list) //[1,2,3,4,5]
console.log(c1.list) //[1,2,3,4,5]

```
::: warning
无法实现多继承
:::


## 构造函数继承 借助 call/apply
``` ts
  function Parent(name){
  this.name=name
  this.list=[1,2,3,4]

}
Parent.prototype.getName(){
   return this.name;
}

function Child(name){
  this.type='child'
  Parent.call(this,name)
}

const c=new Child('c')
console.log(c.name) //c
console.log(c.getName()) //报错

```

除了 Child2 的属性 type 之外，也继承了 Parent2 的属性 name。这样写的时候子类虽然能够拿到父类的属性值，解决了第一种继承方式的弊端，但问题是，只能继承父类的实例属性和方法,不能继承原型属性或者方法。
::: warning
无法继承父类的prototype
:::
上面的两种继承方式各有优缺点，那么结合二者的优点，于是就产生了下面这种组合的继承方式。

## 组合继承

```ts

```
